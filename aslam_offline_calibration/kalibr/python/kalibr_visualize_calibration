#!/usr/bin/env python
import kalibr_common as kc

import argparse
import numpy as np
import pylab as pl
from mpl_toolkits.mplot3d import Axes3D, proj3d
from mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollection


def parseArguments():
    parser = argparse.ArgumentParser(
        description='Visualizes a camchain.yaml or camchain_imu.yaml file.')
    parser.add_argument(
        '--cam',
        dest='chainYaml',
        help='Camera configuration as yaml file.',
        action='append',
        required=True)
    parser.add_argument(
        '--azim',
        dest='azimView',
        help='Azimuth angle of the view.',
        default=0,
        required=False)
    parser.add_argument(
        '--elev',
        dest='elevView',
        help='Elevation angle of the view.',
        default=90,
        required=False)
    parsed_args = parser.parse_args()
    return parsed_args


def printLine():
    print("------------------------")


def axisEqual3D(ax):
    extents = np.array(
        [getattr(ax, 'get_{}lim'.format(dim))() for dim in 'xyz'])
    sz = extents[:, 1] - extents[:, 0]
    centers = np.mean(extents, axis=1)
    maxsize = max(abs(sz))
    r = maxsize / 2
    for ctr, dim in zip(centers, 'xyz'):
        getattr(ax, 'set_{}lim'.format(dim))(ctr - r, ctr + r)
    ax.set_aspect('equal')


def transformPointcloud(transform, points):
    assert transform.shape == (4, 4)
    R = transform[0:3, 0:3].reshape(3, 3)
    t = transform[0:3, 3].reshape(3, 1)
    assert points.shape[1] == 3
    points_transformed = points.copy()
    for index in range(points.shape[0]):
        point = points[index, :].reshape(3, 1)
        point_transformed = R.dot(point) + t
        points_transformed[index, :] = point_transformed.reshape(1, 3)
    return points_transformed


class CalibrationVisualization:

    def __init__(self):
        self.color_counter = 0

    def addCameraPlot(self, ax, T_imu_cam, intrinsics, resolution):
        R_I_C = T_imu_cam[0:3, 0:3].reshape(3, 3)
        t_I_C = T_imu_cam[0:3, 3].reshape(3, 1)
        focal_lengths = intrinsics[0:2]
        principal_point = intrinsics[2:4]
        self.__drawCameraOutline(ax, T_imu_cam, focal_lengths, principal_point,
                               resolution)

    def __drawCameraOutline(self, ax, transform, focal_lengths, principal_point,
                          resolution):
        scaling_factor = 1e-4
        pixel_ratio = focal_lengths[0] / focal_lengths[1]
        scaled_focal_length = scaling_factor * focal_lengths[0]
        x_range = scaling_factor * np.array(
            [-principal_point[0], resolution[0] - principal_point[0]])
        y_range = pixel_ratio * scaling_factor * np.array(
            [-principal_point[1], resolution[1] - principal_point[1]])
        raw_camera_corners = np.array(
            [[x_range[0], y_range[0], scaled_focal_length], [
                x_range[1], y_range[0], scaled_focal_length
            ], [x_range[1], y_range[1], scaled_focal_length],
             [x_range[0], y_range[1], scaled_focal_length], [0, 0, 0]])
        camera_corners = transformPointcloud(transform, raw_camera_corners)
        vertices = [[camera_corners[0], camera_corners[1], camera_corners[4]], [
            camera_corners[0], camera_corners[3], camera_corners[4]
        ], [camera_corners[2], camera_corners[1], camera_corners[4]],
                    [camera_corners[2], camera_corners[3], camera_corners[4]], [
                        camera_corners[0], camera_corners[1], camera_corners[2],
                        camera_corners[3]
                    ]]
        cmap_fill = pl.get_cmap('Pastel1')
        fill_color = cmap_fill(self.color_counter)
        self.color_counter = self.color_counter + 1
        ax.scatter3D(camera_corners[:, 0], camera_corners[:, 1],
                     camera_corners[:, 2])
        ax.add_collection3d(
            Poly3DCollection(
                vertices,
                facecolors=fill_color,
                linewidths=1,
                edgecolors='r',
                alpha=.25))


def getDistance(point, other_point):
    difference_vector = other_point - point
    return np.linalg.norm(difference_vector)


def orthogonalProjection(zfront, zback):
    a = (zfront + zback) / (zfront - zback)
    b = -2 * (zfront * zback) / (zfront - zback)
    return np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, a, b],
                     [0, 0, -0.00001, zback]])


def main():
    print("Loading camera configuration...")
    parsed_args = parseArguments()
    fig = pl.figure()
    ax = fig.gca(projection='3d')
    calibration_visualization = CalibrationVisualization()
    for camchain_yaml in parsed_args.chainYaml:
        camchain = kc.ConfigReader.CameraChainParameters(camchain_yaml)
        num_cameras = camchain.numCameras()
        print("Configuration has " + str(num_cameras) + " cameras .")
        focal_centers = np.zeros([3, 1])
        for cam_index, (cam, value) in enumerate(camchain.data.iteritems()):
            T_imu_cam = camchain.getExtrinsicsImuToCam(cam_index).inverse().T()
            intrinsics = np.asarray(value['intrinsics'])
            resolution = np.asarray(value['resolution'])
            calibration_visualization.addCameraPlot(ax, T_imu_cam, intrinsics,
                                                    resolution)
    ax.view_init(azim=parsed_args.azimView, elev=parsed_args.elevView)
    proj3d.persp_transformation = orthogonalProjection
    axisEqual3D(ax)
    pl.show()


if __name__ == "__main__":
    main()
